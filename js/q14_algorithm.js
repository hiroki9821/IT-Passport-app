export const q14_algorithm = [
  {
    question: "アルゴリズムのフローチャートで処理の開始や終了を表す記号はどれか？",
    choices: [
      "楕円形",
      "長方形",
      "ひし形",
      "平行四辺形"
    ],
    answer: "楕円形",
    explanation: "フローチャートで開始・終了は楕円形（端子）で表される。"
  },
  {
    question: "プログラムにおいて、変数に値を格納する処理を何というか？",
    choices: [
      "代入",
      "比較",
      "分岐",
      "繰返し"
    ],
    answer: "代入",
    explanation: "変数に値を格納する処理は代入と呼ぶ。"
  },
  {
    question: "次のうち、条件によって処理を分ける制御構造はどれか？",
    choices: [
      "分岐",
      "繰返し",
      "代入",
      "順次"
    ],
    answer: "分岐",
    explanation: "条件により処理を分岐させるのが分岐（if文など）である。"
  },
  {
    question: "同じ処理を複数回繰り返し実行する制御構造はどれか？",
    choices: [
      "繰返し",
      "分岐",
      "順次",
      "代入"
    ],
    answer: "繰返し",
    explanation: "繰返しはfor文やwhile文などで表される制御構造。"
  },
  {
    question: "“アルゴリズムの汎用性”とはどのような意味か？",
    choices: [
      "さまざまな状況や入力でも使えること",
      "必ず高速に動作すること",
      "一度しか使えないこと",
      "出力結果が毎回異なること"
    ],
    answer: "さまざまな状況や入力でも使えること",
    explanation: "汎用性の高いアルゴリズムは幅広い用途で再利用できる。"
  },
  {
    question: "“疑似乱数”の特徴はどれか？",
    choices: [
      "計算式によって再現できるランダム値",
      "必ず同じ値になる",
      "完全に予測不能な値",
      "小数のみ扱える"
    ],
    answer: "計算式によって再現できるランダム値",
    explanation: "疑似乱数は規則的な計算式で生成されるが、見かけ上ランダムな値になる。"
  },
  {
    question: "“バグトラッキングシステム”の主な目的はどれか？",
    choices: [
      "ソフトウェア開発時のバグや問題点を管理する",
      "プログラムの速度を測定する",
      "アルゴリズムを高速化する",
      "プログラムの配列を監視する"
    ],
    answer: "ソフトウェア開発時のバグや問題点を管理する",
    explanation: "バグトラッキングシステムは不具合や課題を一元管理できる仕組み。"
  },
  {
    question: "A=10, B=5 のとき、A>B を判定する条件式はどのような結果となるか？",
    choices: [
      "真",
      "偽",
      "エラー",
      "未定義"
    ],
    answer: "真",
    explanation: "A(10)はB(5)より大きいので条件は真となる。"
  },
  {
    question: "フローチャートで入力や出力を表す図形はどれか？",
    choices: [
      "平行四辺形",
      "ひし形",
      "長方形",
      "楕円形"
    ],
    answer: "平行四辺形",
    explanation: "平行四辺形は入力・出力（I/O）を表す。"
  },
  {
    question: "次のアルゴリズムのうち、線形探索法の説明として正しいものはどれか？",
    choices: [
      "先頭から順番に探索する",
      "高速な探索ができる",
      "必ず中央から探索を始める",
      "データが整列されている必要がある"
    ],
    answer: "先頭から順番に探索する",
    explanation: "線形探索はデータの先頭から順に目的値を探す方法。"
  },
  {
    question: "プログラムの処理手順を記述したものを何というか？",
    choices: [
      "アルゴリズム",
      "データベース",
      "ネットワーク",
      "ファイル"
    ],
    answer: "アルゴリズム",
    explanation: "アルゴリズムは処理手順や流れを表現したもの。"
  },
  {
    question: "2分探索法はどのようなデータに適用できるか？",
    choices: [
      "整列されたデータ",
      "重複のないデータ",
      "未整列のデータ",
      "大きなデータのみ"
    ],
    answer: "整列されたデータ",
    explanation: "2分探索法は整列済みデータに適用できる。"
  },
  {
    question: "繰返し構造の代表的な文はどれか？",
    choices: [
      "for文",
      "if文",
      "switch文",
      "return文"
    ],
    answer: "for文",
    explanation: "for文は繰返し構造の代表的な記述方法。"
  },
  {
    question: "条件分岐構造に用いる文として適切なものはどれか？",
    choices: [
      "if文",
      "for文",
      "while文",
      "print文"
    ],
    answer: "if文",
    explanation: "if文は条件による処理の分岐を記述する。"
  },
  {
    question: "次のうち配列の説明として適切なものはどれか？",
    choices: [
      "複数のデータを一括で管理できる",
      "条件判定に使う",
      "一度に1つしかデータを持てない",
      "文字列しか扱えない"
    ],
    answer: "複数のデータを一括で管理できる",
    explanation: "配列は複数のデータを1つの変数でまとめて管理する。"
  },
  {
    question: "“Hello, World!” を出力する命令はどれか？（JavaScriptの場合）",
    choices: [
      "console.log('Hello, World!');",
      "print('Hello, World!');",
      "printf('Hello, World!');",
      "echo('Hello, World!');"
    ],
    answer: "console.log('Hello, World!');",
    explanation: "JavaScriptではconsole.logで出力する。"
  },
  {
    question: "再帰（recursive）処理とはどのようなものか？",
    choices: [
      "関数が自分自身を呼び出す処理",
      "関数が複数回呼ばれる処理",
      "関数の引数を増やす処理",
      "関数の返り値を増やす処理"
    ],
    answer: "関数が自分自身を呼び出す処理",
    explanation: "再帰は、処理の中で同じ処理（自分自身）を呼び出すこと。"
  },
  {
    question: "アルゴリズムの「計算量」とは何を示すか？",
    choices: [
      "処理に必要な計算回数",
      "プログラムの行数",
      "変数の数",
      "メモリ容量"
    ],
    answer: "処理に必要な計算回数",
    explanation: "計算量とは処理にかかる計算ステップ数のこと。"
  },
  {
    question: "プログラムの「バグ」とは何か？",
    choices: [
      "誤った動作やエラーの原因となる欠陥",
      "高速化のための仕組み",
      "ネットワークの遅延",
      "追加機能"
    ],
    answer: "誤った動作やエラーの原因となる欠陥",
    explanation: "バグはプログラムに存在する誤りや欠陥のこと。"
  },
  {
    question: "ソートアルゴリズムの1つで、隣り合うデータ同士を比較して並び替える方法はどれか？",
    choices: [
      "バブルソート",
      "クイックソート",
      "ヒープソート",
      "線形探索"
    ],
    answer: "バブルソート",
    explanation: "バブルソートは隣同士を比較して並び替えるアルゴリズム。"
  },
  {
    question: "“do-while文”の特徴はどれか？",
    choices: [
      "必ず1回は処理が実行される",
      "1回も実行されないことがある",
      "分岐構造である",
      "配列処理専用である"
    ],
    answer: "必ず1回は処理が実行される",
    explanation: "do-while文は条件判定より先に必ず1回処理が行われる。"
  },
  {
    question: "次のうち、“スタック”の特徴として正しいものはどれか？",
    choices: [
      "後入れ先出し（LIFO）",
      "先入れ先出し（FIFO）",
      "ランダムアクセスが可能",
      "データを自動で削除"
    ],
    answer: "後入れ先出し（LIFO）",
    explanation: "スタックは後から入れたものを先に取り出すLIFO構造。"
  },
  {
    question: "次のうち、“キュー”の特徴として正しいものはどれか？",
    choices: [
      "先入れ先出し（FIFO）",
      "後入れ先出し（LIFO）",
      "ツリー構造である",
      "最後に追加したものを先に取り出す"
    ],
    answer: "先入れ先出し（FIFO）",
    explanation: "キューは先に入れたデータから順に取り出すFIFO構造。"
  },
  {
    question: "配列の要素数がN個のとき、インデックスの範囲として正しいものはどれか？（0始まり）",
    choices: [
      "0～N-1",
      "1～N",
      "0～N",
      "1～N-1"
    ],
    answer: "0～N-1",
    explanation: "多くのプログラミング言語では配列のインデックスは0からN-1までとなる。"
  },
  {
    question: "for (let i=0; i<3; i++) { ... } のiの値は、繰り返しのたびにどのように変化するか？",
    choices: [
      "0, 1, 2",
      "1, 2, 3",
      "0, 2, 4",
      "1, 3, 5"
    ],
    answer: "0, 1, 2",
    explanation: "iは0から始まり2まで、3回繰り返される。"
  },
  {
    question: "プログラムの中で値が変わらない定数を使う理由は何か？",
    choices: [
      "保守性や可読性の向上",
      "処理速度の低下",
      "バグを発生しやすくする",
      "変数と同じ意味"
    ],
    answer: "保守性や可読性の向上",
    explanation: "定数を使うことでプログラムの見通しやすさ・保守性が向上する。"
  },
  {
    question: "配列 a = [2, 4, 6] のとき、a[1] の値は？",
    choices: [
      "4",
      "2",
      "6",
      "1"
    ],
    answer: "4",
    explanation: "インデックス1の要素は4。配列は0から始まる。"
  },
  {
    question: "次のうち関数のメリットとして正しいものはどれか？",
    choices: [
      "同じ処理を何度も使い回せる",
      "プログラムのサイズが増える",
      "データベースが必要になる",
      "必ず高速化する"
    ],
    answer: "同じ処理を何度も使い回せる",
    explanation: "関数は処理をまとめて何度も利用できる。"
  },
  {
    question: "論理演算でANDの記号はどれか？（一般的な記号）",
    choices: [
      "&&",
      "||",
      "!",
      "=="
    ],
    answer: "&&",
    explanation: "ANDは「&&」で表される。"
  },
  {
    question: "a = 5, b = 10 のとき、(a < b) && (b < 20) の値は？",
    choices: [
      "真",
      "偽",
      "エラー",
      "未定義"
    ],
    answer: "真",
    explanation: "a < bもb < 20もどちらも真なので結果は真。"
  },
  {
    question: "次のうち、アルゴリズムの評価指標でないものはどれか？",
    choices: [
      "画面の色",
      "計算量",
      "メモリ使用量",
      "処理速度"
    ],
    answer: "画面の色",
    explanation: "画面の色はアルゴリズムの評価とは無関係。"
  },
  {
    question: "整数型と浮動小数点型の違いは何か？",
    choices: [
      "小数が扱えるかどうか",
      "配列としてのみ使える",
      "処理速度が必ず速い",
      "必ず同じ容量"
    ],
    answer: "小数が扱えるかどうか",
    explanation: "整数型は整数のみ、浮動小数点型は小数も扱える。"
  },
  {
    question: "while文の特徴として正しいものはどれか？",
    choices: [
      "条件を満たす間、繰り返す",
      "1回だけ実行される",
      "必ず真になる",
      "条件判定をしない"
    ],
    answer: "条件を満たす間、繰り返す",
    explanation: "while文は条件が真の間、繰り返し処理する。"
  },
  {
    question: "次のうち、文字列を連結する演算子（JavaScriptの場合）はどれか？",
    choices: [
      "+",
      "-",
      "*",
      "/"
    ],
    answer: "+",
    explanation: "JavaScriptでは「+」演算子で文字列の連結ができる。"
  },
  {
    question: "引数と戻り値が両方ある関数の利点はどれか？",
    choices: [
      "柔軟なデータの受け渡しと処理結果の返却ができる",
      "常に高速になる",
      "エラーがなくなる",
      "配列でなければならない"
    ],
    answer: "柔軟なデータの受け渡しと処理結果の返却ができる",
    explanation: "引数で入力し、戻り値で結果を返せるので再利用性や柔軟性が高い。"
  },
  {
    question: "for (let i=1; i<=3; i++) { ... } の繰り返し回数は？",
    choices: [
      "3回",
      "2回",
      "4回",
      "1回"
    ],
    answer: "3回",
    explanation: "i=1,2,3の3回繰り返される。"
  },
  {
    question: "次のうち“スワップ”の説明として正しいものはどれか？",
    choices: [
      "二つの値を入れ替える",
      "変数を削除する",
      "値を倍にする",
      "配列を複製する"
    ],
    answer: "二つの値を入れ替える",
    explanation: "スワップは、二つの値を交換（入れ替え）すること。"
  },
  {
    question: "エラー処理に使われる構文（JavaScript）はどれか？",
    choices: [
      "try-catch",
      "if-switch",
      "for-while",
      "case-else"
    ],
    answer: "try-catch",
    explanation: "try-catch文で例外処理（エラー処理）ができる。"
  },
  {
    question: "条件判定が複数ある場合に使う構造はどれか？",
    choices: [
      "if-else if-else",
      "for文",
      "return文",
      "break文"
    ],
    answer: "if-else if-else",
    explanation: "複数条件の分岐はif-else if-elseで記述できる。"
  },
  {
    question: "プログラムの“無限ループ”とはどのような状態か？",
    choices: [
      "終了条件がなく、永遠に繰り返される",
      "1回だけ実行される",
      "必ずエラーになる",
      "配列が必要"
    ],
    answer: "終了条件がなく、永遠に繰り返される",
    explanation: "無限ループは終わらない繰り返しのこと。"
  },
  {
    question: "アルゴリズム設計における“分割統治法”の特徴は？",
    choices: [
      "問題を小さく分割し、個別に解決後に統合する",
      "一度に全てを処理する",
      "再帰は使えない",
      "探索には使わない"
    ],
    answer: "問題を小さく分割し、個別に解決後に統合する",
    explanation: "分割統治法は問題を小さな部分に分割して解決し、まとめて解を得る手法。"
  },
  {
    question: "関数呼び出し時に使われる“引数”とは何か？",
    choices: [
      "関数に渡す値やデータ",
      "返り値のこと",
      "変数の宣言",
      "コメント文"
    ],
    answer: "関数に渡す値やデータ",
    explanation: "引数は関数へ値やデータを渡すために使われる。"
  },
  {
    question: "if (a === b) の “===” の意味は？",
    choices: [
      "値と型が等しいかどうかの判定",
      "値のみ比較",
      "大きさの比較",
      "代入"
    ],
    answer: "値と型が等しいかどうかの判定",
    explanation: "===は値と型の両方が等しいか判定する（JavaScript）。"
  },
  {
    question: "“再帰呼び出し”を行う際に気を付けるべきことはどれか？",
    choices: [
      "終了条件（ベースケース）を必ず設ける",
      "引数を必ず整数型にする",
      "必ず配列を使う",
      "ループは使えない"
    ],
    answer: "終了条件（ベースケース）を必ず設ける",
    explanation: "終了条件がないと無限再帰になりプログラムが停止しない。"
  },
  {
    question: "プログラムの“コメント”の役割はどれか？",
    choices: [
      "人間が理解しやすいように補足説明を加える",
      "実行速度を上げる",
      "変数を定義する",
      "バグを見つける"
    ],
    answer: "人間が理解しやすいように補足説明を加える",
    explanation: "コメントはプログラム内の説明や備考として記述する。"
  },
  {
    question: "a = a + 1 の処理を1回実行したときのaの変化は？（a=5で開始）",
    choices: [
      "6になる",
      "1になる",
      "0になる",
      "5のまま"
    ],
    answer: "6になる",
    explanation: "aに1を加算して代入するので6になる。"
  },
  {
    question: "for文とwhile文の主な違いはどれか？",
    choices: [
      "繰返し回数が決まっているかどうか",
      "どちらも必ず1回だけ実行される",
      "for文は条件式を書けない",
      "while文は配列でしか使えない"
    ],
    answer: "繰返し回数が決まっているかどうか",
    explanation: "for文は回数が決まっている場合、while文は条件次第で回数が決まらない場合に使われる。"
  },
  {
    question: "配列 a = [1, 3, 5, 7, 9] の合計値を求めるアルゴリズムで正しいものは？",
    choices: [
      "全要素を順に足し合わせる",
      "要素をすべて掛ける",
      "最初と最後だけ足す",
      "偶数だけを足す"
    ],
    answer: "全要素を順に足し合わせる",
    explanation: "合計値は全要素を順に加算して求める。"
  },
  {
    question: "“関数の再利用性”が高いとはどんなことか？",
    choices: [
      "他のプログラムや場面でも使いやすい",
      "一度だけしか使えない",
      "同じ値しか受け取れない",
      "エラーが発生しやすい"
    ],
    answer: "他のプログラムや場面でも使いやすい",
    explanation: "再利用性が高い関数は様々な場所で呼び出せる。"
  },
  {
    question: "“引数なし”の関数の特徴はどれか？",
    choices: [
      "特定の値を外部から受け取らない",
      "必ずエラーになる",
      "戻り値が必要",
      "配列しか扱えない"
    ],
    answer: "特定の値を外部から受け取らない",
    explanation: "引数なしの関数は呼び出し時に値を渡さない。"
  },
  {
    question: "アルゴリズムの“擬似言語（疑似コード）”とはどんなものか？",
    choices: [
      "自然言語とプログラム言語の中間的な記法",
      "HTMLで記述する",
      "必ずC言語で書く",
      "図形のみで表現"
    ],
    answer: "自然言語とプログラム言語の中間的な記法",
    explanation: "擬似言語は人間に分かりやすく、実装言語に依存しない記述方法。"
  },
  {
    question: "論理演算“NOT”の意味として正しいものはどれか？",
    choices: [
      "真偽を反転する",
      "2つの条件を同時に判定",
      "2つの条件のいずれかを判定",
      "値を2倍にする"
    ],
    answer: "真偽を反転する",
    explanation: "NOTは条件の真偽を逆にする論理演算。"
  },
  {
    question: "a = 10; b = a++; 実行後のbの値は？",
    choices: [
      "10",
      "11",
      "0",
      "1"
    ],
    answer: "10",
    explanation: "後置インクリメントでは、bにはaの元の値（10）が入り、その後aは11となる。"
  },
  {
    question: "“アルゴリズムの流れ図（フローチャート）”で条件分岐を表す図形は？",
    choices: [
      "ひし形",
      "長方形",
      "楕円形",
      "平行四辺形"
    ],
    answer: "ひし形",
    explanation: "フローチャートで条件分岐はひし形で表す。"
  },
  {
    question: "バブルソートの特徴として誤っているものはどれか？",
    choices: [
      "大きなデータの並び替えに高速である",
      "隣り合う要素を比較して並べ替える",
      "実装が簡単である",
      "安定なソートである"
    ],
    answer: "大きなデータの並び替えに高速である",
    explanation: "バブルソートは大規模データでは非効率（遅い）。"
  },
  {
    question: "スタック操作で“push”とはどんな操作か？",
    choices: [
      "データを積む（追加）",
      "データを取り出す",
      "データを削除する",
      "データを検索する"
    ],
    answer: "データを積む（追加）",
    explanation: "pushはスタックにデータを積む（追加）操作。"
  },
  {
    question: "“pop”とはスタック構造で何を行うか？",
    choices: [
      "一番上のデータを取り出す",
      "一番下のデータを削除する",
      "データを検索する",
      "全て削除する"
    ],
    answer: "一番上のデータを取り出す",
    explanation: "popはスタックのトップからデータを取り出す操作。"
  },
  {
    question: "キュー構造の“enqueue”の意味はどれか？",
    choices: [
      "データを追加する",
      "データを取り出す",
      "データを逆順にする",
      "データを削除する"
    ],
    answer: "データを追加する",
    explanation: "enqueueはキューの末尾にデータを追加する操作。"
  },
  {
    question: "“dequeue”とはキュー構造でどんな操作か？",
    choices: [
      "先頭のデータを取り出す",
      "末尾のデータを削除する",
      "データを積む",
      "データを検索する"
    ],
    answer: "先頭のデータを取り出す",
    explanation: "dequeueはキューの先頭からデータを取り出す操作。"
  },
  {
    question: "“配列の添字（インデックス）”の意味はどれか？",
    choices: [
      "各要素の位置を示す番号",
      "配列の名前",
      "要素数",
      "メモリ容量"
    ],
    answer: "各要素の位置を示す番号",
    explanation: "インデックスは配列内の要素の位置番号。"
  },
  {
    question: "“変数のスコープ”とは何を意味するか？",
    choices: [
      "変数が有効な範囲",
      "変数の型",
      "変数名の長さ",
      "変数の値"
    ],
    answer: "変数が有効な範囲",
    explanation: "スコープは変数が参照・利用できる範囲のこと。"
  },
  {
    question: "次のうち“ローカル変数”の特徴として正しいものはどれか？",
    choices: [
      "関数やブロック内でのみ有効",
      "プログラム全体で使える",
      "配列専用である",
      "メモリに保存されない"
    ],
    answer: "関数やブロック内でのみ有効",
    explanation: "ローカル変数は宣言された範囲内のみで利用可能。"
  },
  {
    question: "“グローバル変数”の特徴はどれか？",
    choices: [
      "プログラム全体で利用できる",
      "関数内でのみ有効",
      "一度だけ使える",
      "値が自動で消える"
    ],
    answer: "プログラム全体で利用できる",
    explanation: "グローバル変数はどこからでも参照できる変数。"
  },
  {
    question: "“再帰的アルゴリズム”の計算量が大きくなりすぎる原因として正しいものはどれか？",
    choices: [
      "呼び出し回数が爆発的に増える場合がある",
      "ループを使っていないから",
      "変数が多いから",
      "必ず無限ループになるから"
    ],
    answer: "呼び出し回数が爆発的に増える場合がある",
    explanation: "再帰は分岐が多い場合、計算量が急増しやすい。"
  },
  {
    question: "“線形探索法”の計算量（時間計算量）は一般にどの程度か？（N個のデータ）",
    choices: [
      "O(N)",
      "O(1)",
      "O(N^2)",
      "O(log N)"
    ],
    answer: "O(N)",
    explanation: "線形探索は全ての要素を調べるため、O(N)となる。"
  },
  {
    question: "“2分探索法”の計算量は一般にどの程度か？（N個のデータ）",
    choices: [
      "O(log N)",
      "O(N^2)",
      "O(N)",
      "O(1)"
    ],
    answer: "O(log N)",
    explanation: "2分探索法はデータを半分ずつ絞り込むのでO(log N)。"
  },
  {
    question: "“クイックソート”の特徴はどれか？",
    choices: [
      "高速なソートアルゴリズムである",
      "必ず安定なソートである",
      "非常に簡単なアルゴリズムである",
      "配列の大きさに関わらず常にO(1)"
    ],
    answer: "高速なソートアルゴリズムである",
    explanation: "クイックソートは高速だが、安定なソートではない。"
  },
  {
    question: "“安定なソート”とはどんな特徴か？",
    choices: [
      "同じ値の要素の順序が保たれる",
      "必ず計算量が小さい",
      "データを削除しながら並び替える",
      "必ず高速である"
    ],
    answer: "同じ値の要素の順序が保たれる",
    explanation: "安定なソートは、同じ値の順序が元のまま。"
  },
  {
    question: "“バブルソート”の平均的な計算量は？（N個のデータ）",
    choices: [
      "O(N^2)",
      "O(1)",
      "O(N)",
      "O(log N)"
    ],
    answer: "O(N^2)",
    explanation: "バブルソートの計算量はO(N^2)と効率が悪い。"
  },
  {
    question: "“挿入ソート”はどのような場合に有効か？",
    choices: [
      "データ量が少ない場合",
      "データ量が非常に多い場合",
      "データが常に昇順の場合",
      "ランダムアクセスが必要な場合"
    ],
    answer: "データ量が少ない場合",
    explanation: "挿入ソートは小規模データに向く。"
  },
  {
    question: "“ヒープソート”の計算量は？（N個のデータ）",
    choices: [
      "O(N log N)",
      "O(N^2)",
      "O(N)",
      "O(1)"
    ],
    answer: "O(N log N)",
    explanation: "ヒープソートはO(N log N)の計算量。"
  },
  {
    question: "“配列”と“リスト構造”の主な違いはどれか？",
    choices: [
      "リストは途中の要素も簡単に追加・削除できる",
      "配列の方が常に高速",
      "リストはランダムアクセスができる",
      "配列はサイズ変更が容易"
    ],
    answer: "リストは途中の要素も簡単に追加・削除できる",
    explanation: "リスト構造は挿入・削除が柔軟。"
  },
  {
    question: "“リンクリスト”の特徴はどれか？",
    choices: [
      "各要素が次の要素の情報を持つ",
      "配列よりも常に高速",
      "メモリを大量に消費する",
      "一度しか使えない"
    ],
    answer: "各要素が次の要素の情報を持つ",
    explanation: "リンクリストは次の要素のアドレス（ポインタ）を持つ。"
  },
  {
    question: "“木構造（ツリー構造）”の特徴はどれか？",
    choices: [
      "階層的な親子関係を持つ",
      "常に配列で実装される",
      "1つの要素しか持てない",
      "必ず循環する"
    ],
    answer: "階層的な親子関係を持つ",
    explanation: "ツリーは階層構造（親子関係）が特徴。"
  },
  {
    question: "“ハッシュ法”の特徴はどれか？",
    choices: [
      "高速にデータの検索ができる",
      "必ず順番に検索する",
      "計算量が常にO(N^2)",
      "配列のみで使える"
    ],
    answer: "高速にデータの検索ができる",
    explanation: "ハッシュ法はデータ検索を高速に行えるアルゴリズム。"
  },
  {
    question: "“線形探索”と“2分探索”の大きな違いは何か？",
    choices: [
      "2分探索はデータが整列されている必要がある",
      "線形探索は高速である",
      "2分探索は必ず遅い",
      "線形探索は配列で使えない"
    ],
    answer: "2分探索はデータが整列されている必要がある",
    explanation: "2分探索は整列済みデータが必須。"
  },
  {
    question: "“ループのネスト”とは何か？",
    choices: [
      "ループの中にさらにループがある構造",
      "条件分岐が複数ある",
      "関数が再帰的に呼ばれる",
      "配列を二重に宣言する"
    ],
    answer: "ループの中にさらにループがある構造",
    explanation: "ネストは入れ子のこと。"
  },
  {
    question: "“配列の長さ”を取得するプロパティ（JavaScript）はどれか？",
    choices: [
      ".length",
      ".size",
      ".count",
      ".number"
    ],
    answer: ".length",
    explanation: "配列名.length で要素数が取得できる。"
  },
  {
    question: "“break文”の役割として正しいものはどれか？",
    choices: [
      "ループやswitch文から抜ける",
      "新しい変数を作る",
      "配列を作成する",
      "値を比較する"
    ],
    answer: "ループやswitch文から抜ける",
    explanation: "breakは繰り返しやswitchから強制的に抜ける命令。"
  },
  {
    question: "“continue文”の役割として正しいものはどれか？",
    choices: [
      "ループの次の繰り返しに進む",
      "ループを終了する",
      "新しい配列を作る",
      "変数の初期化"
    ],
    answer: "ループの次の繰り返しに進む",
    explanation: "continueは現在の繰り返しをスキップし、次へ進む。"
  },
  {
    question: "“switch文”の用途はどれか？",
    choices: [
      "複数の条件分岐をまとめて書く",
      "ループ処理に使う",
      "配列の初期化",
      "コメントを書く"
    ],
    answer: "複数の条件分岐をまとめて書く",
    explanation: "switch文は多岐分岐をシンプルに記述できる。"
  },
  {
    question: "“default”はswitch文でどんな時に使うか？",
    choices: [
      "どのcaseにも一致しなかった場合の処理",
      "最初のcaseで必ず実行",
      "繰り返しの最後に実行",
      "ループから抜ける時"
    ],
    answer: "どのcaseにも一致しなかった場合の処理",
    explanation: "defaultはswitchで該当caseがない場合に実行される。"
  },
  {
    question: "“インクリメント”とはどのような操作か？",
    choices: [
      "値を1増やす",
      "値を2倍にする",
      "値を1減らす",
      "配列を初期化する"
    ],
    answer: "値を1増やす",
    explanation: "インクリメントは値を1だけ増やす操作。"
  },
  {
    question: "“デクリメント”とはどのような操作か？",
    choices: [
      "値を1減らす",
      "値を1増やす",
      "値を0にする",
      "配列を空にする"
    ],
    answer: "値を1減らす",
    explanation: "デクリメントは変数の値を1だけ減らす操作。"
  },
  {
    question: "“配列の初期化”とはどのような処理か？",
    choices: [
      "全ての要素に初期値を設定する",
      "配列名を変更する",
      "全ての要素を削除する",
      "配列のサイズを変更する"
    ],
    answer: "全ての要素に初期値を設定する",
    explanation: "配列の初期化は要素に最初の値をセットすること。"
  },
  {
    question: "“多次元配列”の特徴はどれか？",
    choices: [
      "配列の中に配列を持つ",
      "変数しか扱えない",
      "必ず1次元しか持てない",
      "1つのデータしか入らない"
    ],
    answer: "配列の中に配列を持つ",
    explanation: "多次元配列は配列の要素がさらに配列になっている。"
  },
  {
    question: "“アルゴリズムの最適化”とはどのようなことか？",
    choices: [
      "より効率的な手順に改善する",
      "プログラムの行数を増やす",
      "常に新しい言語で書き換える",
      "変数名を変更する"
    ],
    answer: "より効率的な手順に改善する",
    explanation: "最適化は無駄を省き処理を効率化すること。"
  },
  {
    question: "“配列の逆順処理”を行う理由として適切なものは？",
    choices: [
      "データを後ろから利用したい場合",
      "エラーを発生させるため",
      "配列を削除するため",
      "計算量を増やすため"
    ],
    answer: "データを後ろから利用したい場合",
    explanation: "逆順処理は末尾から順にデータを使いたいときに利用される。"
  },
  {
    question: "“選択ソート”の特徴はどれか？",
    choices: [
      "未整列部分の最小値（または最大値）を順に選んで並べる",
      "隣り合う要素だけを比較する",
      "必ず安定なソートである",
      "再帰でのみ実装できる"
    ],
    answer: "未整列部分の最小値（または最大値）を順に選んで並べる",
    explanation: "選択ソートは未整列部分の中から最小（最大）値を探して順に並べる。"
  },
  {
    question: "“フラグ変数”の用途として正しいものはどれか？",
    choices: [
      "特定の条件を記録するために使う",
      "配列の長さを保存するため",
      "全てのデータを削除するため",
      "プログラムの名前を保存するため"
    ],
    answer: "特定の条件を記録するために使う",
    explanation: "フラグ変数は何らかの状態や条件を一時的に記録するために使う。"
  },
  {
    question: "“乱数”を利用する理由として最も適切なものは？",
    choices: [
      "処理を毎回ランダムにしたいとき",
      "エラー処理を高速化するため",
      "配列を削除するため",
      "変数の初期化のため"
    ],
    answer: "処理を毎回ランダムにしたいとき",
    explanation: "乱数はゲームのランダム要素やテストデータ生成などに使われる。"
  },
  {
    question: "“サブルーチン”とはどのようなものか？",
    choices: [
      "処理をひとまとまりにした小さなプログラム",
      "メインプログラムを削除する命令",
      "全ての変数をまとめる構造体",
      "エラー処理の名前"
    ],
    answer: "処理をひとまとまりにした小さなプログラム",
    explanation: "サブルーチンは、繰り返し使う処理をまとめた小プログラム。"
  },
  {
    question: "“グローバル変数”のデメリットはどれか？",
    choices: [
      "予期せぬ場所で値が変更されやすい",
      "常に高速になる",
      "メモリを節約できる",
      "関数の外で使えない"
    ],
    answer: "予期せぬ場所で値が変更されやすい",
    explanation: "グローバル変数はどこからでも変更できるため、バグの原因になりやすい。"
  },
  {
    question: "“局所変数（ローカル変数）”のメリットはどれか？",
    choices: [
      "他の処理への影響を防げる",
      "プログラム全体で必ず使える",
      "常にグローバル変数より速い",
      "エラー処理に使う"
    ],
    answer: "他の処理への影響を防げる",
    explanation: "ローカル変数は影響範囲が限定されるため安全。"
  },
  {
    question: "“フィボナッチ数列”の特徴はどれか？",
    choices: [
      "直前の2つの数を足して次の数になる",
      "すべて同じ値になる",
      "3つ前の数を足す",
      "必ず0から始まる"
    ],
    answer: "直前の2つの数を足して次の数になる",
    explanation: "フィボナッチ数列はn番目＝n-1番目＋n-2番目。"
  },
  {
    question: "“再帰関数”の計算量が大きいときに使うべき対策はどれか？",
    choices: [
      "メモ化（結果の保存）やループ処理に書き換える",
      "関数名を変更する",
      "引数を増やす",
      "バグを放置する"
    ],
    answer: "メモ化（結果の保存）やループ処理に書き換える",
    explanation: "計算結果の保存や反復構造への書き換えで効率化できる。"
  },
  {
    question: "“再帰関数”の実行時、主に利用されるデータ構造は？",
    choices: [
      "スタック",
      "キュー",
      "配列",
      "ツリー"
    ],
    answer: "スタック",
    explanation: "再帰呼び出しはスタックを使って状態を保持する。"
  },
  {
    question: "“アルゴリズム”に関する次の説明のうち正しいものはどれか？",
    choices: [
      "ある問題を解決するための手順や方法のこと",
      "必ずプログラムで書かれるもの",
      "実行環境が異なると意味が変わる",
      "入力が必要ない"
    ],
    answer: "ある問題を解決するための手順や方法のこと",
    explanation: "アルゴリズムは問題解決のための手順やルールを示す。"
  },
  {
    question: "“プログラムのデバッグ”とは何か？",
    choices: [
      "プログラムの誤りを発見し修正する作業",
      "新しい機能を追加する作業",
      "画面のデザインを作る作業",
      "メモリを初期化する作業"
    ],
    answer: "プログラムの誤りを発見し修正する作業",
    explanation: "デバッグはバグ（誤り）を見つけて修正する作業。"
  },
  {
    question: "“アルゴリズムの正当性”とはどのような意味か？",
    choices: [
      "どんな入力に対しても正しい結果を出すこと",
      "必ず高速に動作すること",
      "メモリ使用量が少ないこと",
      "エラーを出さないこと"
    ],
    answer: "どんな入力に対しても正しい結果を出すこと",
    explanation: "アルゴリズムの正当性は、正しく解を導く性質をいう。"
  }
];
